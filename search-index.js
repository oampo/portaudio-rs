var searchIndex = {};
searchIndex['portaudio'] = {"items":[[0,"","portaudio","PortAudio bindings for Rust"],[0,"stream","","Contains the Stream class and associated values"],[1,"StreamTimeInfo","portaudio::stream","Time information for various stream related values"],[11,"input_adc_time","","Timestamp for the ADC capture time of the first frame",0],[11,"current_time","","Timestamp that the callback was invoked",0],[11,"output_dac_time","","Timestamp for the DAC output time of the first frame",0],[1,"StreamCallbackFlags","","Flags indicating the status of the callback"],[1,"StreamFlags","","Flags used to control the behavior of a stream"],[1,"Stream","","An object for an PortAudio stream"],[1,"StreamParameters","","Stream parameters to be used with Stream::open()"],[11,"device","","Index of the device to use",1],[11,"channel_count","","Requested number of channels",1],[11,"suggested_latency","","Desired latency of the stream",1],[1,"StreamInfo","","Information about the actual latency and sample rate values the stream uses"],[11,"input_latency","","Input latency",2],[11,"output_latency","","Output latency",2],[11,"sample_rate","","Sample rate",2],[2,"StreamCallbackResult","","Allowable return values for a StreamCallback"],[12,"Continue","","Continue invoking the callback",3],[12,"Complete","","Stop invoking the callback and finish once everything has played",3],[12,"Abort","","Stop invoking the callback and finish as soon as possible",3],[3,"is_format_supported","","Returns Ok when the StreamParameters are supported. This ignores the latency field."],[4,"StreamCallback","","Callback to consume, process or generate audio"],[4,"StreamFinishedCallback","","Callback to be fired when a StreamCallback is stopped"],[5,"FRAMES_PER_BUFFER_UNSPECIFIED","","Argument to Stream::open() or Stream::open_default() to allow PortAudio itself determine the\noptimal number of frames per buffer. This number may differ each time the callback is called."],[18,"INPUT_UNDERFLOW","","Indicates that the callback has inserted one or more zeroes since not enough data was available"],[18,"INPUT_OVERFLOW","","Indicates that the callback has discarded some data"],[18,"OUTPUT_UNDERFLOW","","Indicates that extra data was inserted in the output since there was not engough available"],[18,"OUTPUT_OVERFLOW","","Indicates that certain data was discarded since there was no room"],[18,"PRIMING_OUTPUT","","Some or all of the output data will be used to prime the stream, input data may be zero"],[18,"CLIP_OFF","","Disable clipping of out of range samples"],[18,"DITHER_OFF","","Disable dithering"],[18,"NEVER_DROP_INPUT","","Request that a full duplex stream will not discard overflowed input samples. The frames_per_buffer must be set to unspecified (0)"],[18,"PRIME_OUTPUT_BUFFERS_USING_STREAM_CALLBACK","","Call the stream callback to fill initial output buffers, rather than priming the buffers with silence"],[18,"PLATFORM_SPECIFIC","","Range for platform specific flags. Not all of the upper 16 bits need to be set at the same time."],[6,"SampleType","","Types that are allowed to be used as samples in a Stream"],[9,"sample_format","","Should return the PortAudio flag which corresponds to the type",4],[10,"hash","","",5],[10,"cmp","","",5],[10,"partial_cmp","","",5],[10,"lt","","",5],[10,"le","","",5],[10,"gt","","",5],[10,"ge","","",5],[10,"clone","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"empty","","Returns an empty set of flags.",5],[10,"all","","Returns the set containing all flags.",5],[10,"bits","","Returns the raw value of the flags currently stored.",5],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",5],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",5],[10,"is_empty","","Returns `true` if no flags are currently stored.",5],[10,"is_all","","Returns `true` if all flags are currently set.",5],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",5],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",5],[10,"insert","","Inserts the specified flags in-place.",5],[10,"remove","","Removes the specified flags in-place.",5],[10,"toggle","","Toggles the specified flags in-place.",5],[4,"Output","",""],[10,"bitor","","Returns the union of the two sets of flags.",5],[4,"Output","",""],[10,"bitxor","","Returns the left flags, but with all the right flags toggled.",5],[4,"Output","",""],[10,"bitand","","Returns the intersection between the two sets of flags.",5],[4,"Output","",""],[10,"sub","","Returns the set difference of the two sets of flags.",5],[4,"Output","",""],[10,"not","","Returns the complement of this set of flags.",5],[10,"hash","","",6],[10,"cmp","","",6],[10,"partial_cmp","","",6],[10,"lt","","",6],[10,"le","","",6],[10,"gt","","",6],[10,"ge","","",6],[10,"clone","","",6],[10,"eq","","",6],[10,"ne","","",6],[10,"empty","","Returns an empty set of flags.",6],[10,"all","","Returns the set containing all flags.",6],[10,"bits","","Returns the raw value of the flags currently stored.",6],[10,"from_bits","","Convert from underlying bit representation, unless that\nrepresentation contains bits that do not correspond to a flag.",6],[10,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits\nthat do not correspond to flags.",6],[10,"is_empty","","Returns `true` if no flags are currently stored.",6],[10,"is_all","","Returns `true` if all flags are currently set.",6],[10,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",6],[10,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",6],[10,"insert","","Inserts the specified flags in-place.",6],[10,"remove","","Removes the specified flags in-place.",6],[10,"toggle","","Toggles the specified flags in-place.",6],[4,"Output","",""],[10,"bitor","","Returns the union of the two sets of flags.",6],[4,"Output","",""],[10,"bitxor","","Returns the left flags, but with all the right flags toggled.",6],[4,"Output","",""],[10,"bitand","","Returns the intersection between the two sets of flags.",6],[4,"Output","",""],[10,"sub","","Returns the set difference of the two sets of flags.",6],[4,"Output","",""],[10,"not","","Returns the complement of this set of flags.",6],[10,"open_default","","Constructs a stream using the default input and output devices",7],[10,"open","","Constructs a stream with the desired input and output specifications",7],[10,"start","","Starts the stream",7],[10,"stop","","Stops the stream. It will block untill all audio has finished playing",7],[10,"abort","","Stop stream immediately without waiting for the buffers to complete",7],[10,"is_stopped","","Returns wether the stream is stopped",7],[10,"is_active","","Returns wether the stream is active",7],[10,"num_read_available","","Get the number of frames that can be read from the stream without waiting",7],[10,"num_write_available","","Get the number of frames that can be written to the stream without waiting",7],[10,"write","","Write the given buffer to the stream. This function blocks",7],[10,"read","","Reads the requested number of frames from the input devices. This function blocks until\nthe whole buffer has been filled.",7],[10,"cpu_load","","Returns the cpu load the stream callback consumes. This will return 0.0 if the stream uses\nblocking read/write, or if an error occured.",7],[10,"time","","Get the current timestamp of the stream",7],[10,"info","","Get the actual latencies and sample rate",7],[10,"set_finished_callback","","Set a callback which is to be called when the StreamCallback finishes",7],[10,"unset_finished_callback","","Remove any previously attached finish callback",7],[10,"drop","","",7],[0,"pa","portaudio","General utilities for PortAudio"],[2,"PaError","portaudio::pa","Enum for all possible errors given by PortAudio"],[12,"NotInitialized","","",8],[12,"UnanticipatedHostError","","",8],[12,"InvalidChannelCount","","",8],[12,"InvalidSampleRate","","",8],[12,"InvalidDevice","","",8],[12,"InvalidFlag","","",8],[12,"SampleFormatNotSupported","","",8],[12,"BadIODeviceCombination","","",8],[12,"InsufficientMemory","","",8],[12,"BufferTooBig","","",8],[12,"BufferTooSmall","","",8],[12,"NullCallback","","",8],[12,"BadStreamPtr","","",8],[12,"TimedOut","","",8],[12,"InternalError","","",8],[12,"DeviceUnavailable","","",8],[12,"IncompatibleHostApiSpecificStreamInfo","","",8],[12,"StreamIsStopped","","",8],[12,"StreamIsNotStopped","","",8],[12,"InputOverflowed","","",8],[12,"OutputUnderflowed","","",8],[12,"HostApiNotFound","","",8],[12,"InvalidHostApi","","",8],[12,"CanNotReadFromACallbackStream","","",8],[12,"CanNotWriteToACallbackStream","","",8],[12,"CanNotReadFromAnOutputOnlyStream","","",8],[12,"CanNotWriteToAnInputOnlyStream","","",8],[12,"IncompatibleStreamHostApi","","",8],[12,"BadBufferPtr","","",8],[12,"UnknownError","","Added variant for when FromPrimitive returns None",8],[3,"version","","PortAudio version"],[3,"version_text","","Human-readable PortAudio version"],[3,"initialize","","Initialize the PortAudio API"],[3,"terminate","","Terminate the PortAudio API"],[4,"PaResult","","A result type wrapping PaError."],[10,"eq","","",8],[10,"ne","","",8],[10,"from_i64","","",8],[10,"from_u64","","",8],[10,"fmt","","",8],[0,"hostapi","portaudio","Info module for available audio host API's"],[1,"HostApiInfo","portaudio::hostapi","Information about a specific host API"],[11,"api_type","","The type of the API",9],[11,"name","","Human-readable name of the API",9],[11,"device_count","","Number of devices this API has",9],[11,"default_input","","Default input device of the API. Is None if there is no input device available.",9],[11,"default_output","","Default output device of the API. Is None if there is no output device available.",9],[1,"HostErrorInfo","","Error info obtained by get_last_error"],[11,"code","","The error code given",10],[11,"text","","A human readable error message",10],[11,"api_type","","The type of the API that produced the error",10],[2,"HostApiType","","Possible Host API types"],[12,"InDevelopment","","",11],[12,"DirectSound","","",11],[12,"MME","","",11],[12,"ASIO","","",11],[12,"SoundManager","","",11],[12,"CoreAudio","","",11],[12,"OSS","","",11],[12,"ALSA","","",11],[12,"AL","","",11],[12,"BeOS","","",11],[12,"WDMKS","","",11],[12,"JACK","","",11],[12,"WASAPI","","",11],[12,"AudioScienceHPI","","",11],[12,"Unknown","","Added for when FromPrimitive returns None",11],[3,"get_last_error","","Return information about the last host error encountered."],[3,"get_count","","Get the number of host API's available"],[3,"get_default_index","","Get the default Host API"],[3,"get_info","","Get information about a specific Host API"],[4,"HostApiIndex","","Index number of a Host API"],[10,"from_i64","","",11],[10,"from_u64","","",11],[10,"to_api_index","","Convert a static host API unique identifier, into a runtime host API index.",11],[0,"device","portaudio","Info about connected audio devices"],[1,"DeviceInfo","portaudio::device","Information for a specific device"],[11,"name","","Human readable name",12],[11,"host_api","","Index of the host API this device belongs to",12],[11,"max_input_channels","","Maximal number of input channels that can be used",12],[11,"max_output_channels","","Maximal number of ouput channels that can be used",12],[11,"default_low_input_latency","","Default input latency for interactive performance",12],[11,"default_low_output_latency","","Default output latency for interactive performance",12],[11,"default_high_input_latency","","Default input latency for robust non-interactive applications",12],[11,"default_high_output_latency","","Default output latency for robust non-interactive applications",12],[11,"default_sample_rate","","Default sample rate",12],[3,"get_count","","Retrieve the number of available devices."],[3,"get_default_input_index","","Retrieve the index of the default input device"],[3,"get_default_output_index","","Retrieve the index of the default output device"],[3,"get_info","","Get info about a particular device"],[3,"get_from_host_api_device_index","","Converts a device index from a specific host API to a global device index"],[4,"DeviceIndex","","Index of a Device"]],"paths":[[1,"StreamTimeInfo"],[1,"StreamParameters"],[1,"StreamInfo"],[2,"StreamCallbackResult"],[6,"SampleType"],[1,"StreamCallbackFlags"],[1,"StreamFlags"],[1,"Stream"],[2,"PaError"],[1,"HostApiInfo"],[1,"HostErrorInfo"],[2,"HostApiType"],[1,"DeviceInfo"]]};
initSearch(searchIndex);
